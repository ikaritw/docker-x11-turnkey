package com.tradevan.gateway.client.task.upload.upCast;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.apache.commons.validator.GenericValidator;

import com.tradevan.gateway.client.dao.bean.FromConfig;
import com.tradevan.gateway.client.dao.bean.TurnkeyMessageLog;
import com.tradevan.gateway.client.dao.service.FromConfigService;
import com.tradevan.gateway.client.dao.service.TurnkeyMessageLogService;
import com.tradevan.gateway.client.dao.service.TurnkeySequenceService;
import com.tradevan.gateway.client.einv.charset.CharsetException;
import com.tradevan.gateway.client.einv.charset.CharsetHelper;
import com.tradevan.gateway.client.einv.parse.ParserHelper;
import com.tradevan.gateway.client.einv.transform.TransformException;
import com.tradevan.gateway.client.einv.transform.TransformHelper;
import com.tradevan.gateway.client.einv.transport.ProcessType;
import com.tradevan.gateway.client.einv.util.EINVVersion;
import com.tradevan.gateway.client.einv.util.EncodingType;
import com.tradevan.gateway.client.einv.util.InvoiceUtil;
import com.tradevan.gateway.client.einv.validate.ValidateHelper;
import com.tradevan.gateway.client.exception.TurnkeyException;
import com.tradevan.gateway.client.task.Processor;
import com.tradevan.gateway.client.task.info.CastInfo;
import com.tradevan.gateway.client.task.info.FileFormat;
import com.tradevan.gateway.client.task.upload.PackProcessor;
import com.tradevan.gateway.client.task.upload.UpCastProcessor;
import com.tradevan.gateway.client.util.GatewayUtil;
import com.tradevan.gateway.client.util.TaskEnum;
import com.tradevan.gateway.client.util.TurnkeyConfig;
import com.tradevan.gateway.client.util.TurnkeyConstant;
import com.tradevan.gateway.client.util.TurnkeyLogger;
import com.tradevan.gateway.client.util.TurnkeyLoggerHandler;
import com.tradevan.gateway.client.util.TurnkeyUtil;
import com.tradevan.gateway.einv.msg.EINVPayload;
import com.tradevan.taurus.xdao.XdaoException;

public abstract class UpCaster {

    protected Map<String, CastBean> xmlMap = new HashMap<String, CastBean>();

    protected CastInfo info = null;
    protected ValidateHelper validateHelper = null;
    protected ParserHelper parserHelper = null;
    protected TransformHelper transformHelper = null;
    protected CharsetHelper charsetHelper = null;
    protected int totalCnt = 0; // 總記數器，記錄總處理筆數
    private String MAX_FILE_NUMBER="MAX_FILE_NUMBER";
    private int maxFileNumber=10000;
    protected TurnkeyLoggerHandler logger = TurnkeyLogger.getLogger();
    protected FromConfig storageAgentFromCfg = null; //代理人資訊
    public void setValidateHelper(ValidateHelper validateHelper) {
        this.validateHelper = validateHelper;
    }


    public void setParserHelper(ParserHelper parserHelper) {
        this.parserHelper = parserHelper;
    }

    public void setTransformHelper(TransformHelper transformHelper) {
        this.transformHelper = transformHelper;
    }

    public void setCharsetHelper(CharsetHelper charsetHelper) {
        this.charsetHelper = charsetHelper;
    }

    private void init() {
        if (parserHelper == null)
            parserHelper = new ParserHelper();
        if (validateHelper == null)
            validateHelper = new ValidateHelper();
        if (transformHelper == null)
            transformHelper = new TransformHelper();
        if (charsetHelper == null)
            charsetHelper = new CharsetHelper();
    }

    public void process(CastInfo info) throws XdaoException, IOException {
        init();
        String methodName = "process";
        this.info = info;
        
        xmlMap = new HashMap<String, CastBean>();
        
        if(info.getProcessType()==ProcessType.STORAGE){
            //存放時查詢
            storageAgentFromCfg = FromConfigService.INSTANCE.queryStorageAgent();
        }
        File srcPath = info.getSrcPath();
        if (!srcPath.exists()){
            srcPath.mkdirs();
        }
        
        if (srcPath.listFiles() == null)// 判斷是否有目錄下是否有檔案
            return;

        Set<File> chkFileSet = new HashSet<File>();
        if(!GenericValidator.isBlankOrNull(TurnkeyConfig.getUserCfg().getCharasetMappingTable())){
            charsetHelper.setMapperTablePath(TurnkeyConfig.getUserCfg().getCharasetMappingTable());
        }
        
        if(!GenericValidator.isBlankOrNull(System.getProperty(MAX_FILE_NUMBER)))
        {
        	try{
        		maxFileNumber=Integer.parseInt(System.getProperty(MAX_FILE_NUMBER));
        	}catch(Exception e)
        	{
        		logger.error("Can not parse the MAX_FILE_NUMBER:" +System.getProperty(MAX_FILE_NUMBER)+" to integer", methodName);
        		maxFileNumber=10000;
        	}
        }
        
        File[] files = srcPath.listFiles();
        while (files!=null && files.length > 0) {
            Set<File> processFileSet = new HashSet<File>();
            for (File invoiceFile : files) {
                if(invoiceFile.isDirectory()){
                    continue;
                }
                if(invoiceFile.length()==0)//檔案大小為0 不處理
                {
                	logger.info("The file size of "+invoiceFile.getName()+" is 0, turnkey wont handle it", methodName);
                	continue;
                }
                if(!invoiceFile.canWrite()){
                    logger.info("invoiceFile can not write, escape..", methodName);
                    logger.showConsoleInfo(UpCastProcessor.TASK, invoiceFile + " " + TurnkeyUtil.getMessage("UTL_M0011"), methodName);
                    continue;
                }
                
                if(TurnkeyUtil.isWindows() && !invoiceFile.renameTo(invoiceFile)){
                    logger.info("file can not rename, escape", methodName);
                    continue;
                }
                //可以處理的檔案
                processFileSet.add(invoiceFile);
            }

            if(processFileSet.size()==0){
                logger.info("no file can be process..", methodName);
                logger.showConsoleInfo(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0012"), methodName);
                break;
            }

            if(chkFileSet.size()==0){
                chkFileSet = processFileSet;
            }else{
                int cntSame = 0;
                for(File f: chkFileSet){
                    if(processFileSet.contains(f)){
                        cntSame++;
                    }
                }
                if(processFileSet.size()==cntSame && chkFileSet.size()==cntSame){
                    break;
                }else{
                	//2012.07.18 2775 更新清單
                	chkFileSet = processFileSet;
                }
            }
            
            files = new File[processFileSet.size()];
            int q=0;
            for(File f: processFileSet){
                files[q] = f;
                q++;
            }
            files = TurnkeyUtil.sortFileNameByLastModifiedTime(files);
            
            for (File invoiceFile : files) {
                if(invoiceFile.isDirectory()){
                    continue;
                }
                
                if(!invoiceFile.canWrite()){
                    logger.info("invoiceFile can not write, escape..", methodName);
                    logger.showConsoleInfo(UpCastProcessor.TASK, invoiceFile + " " + TurnkeyUtil.getMessage("UTL_M0011"), methodName);
                    continue;
                }

                if (Processor.isInterruptFlag() || totalCnt > maxFileNumber)
                    break;
                // 取得編碼後的seqNo
                String seqNo = TurnkeySequenceService.INSTANCE.getNextSequence();
                try {
                    logger.info("process file name: " + invoiceFile, methodName);
                    logger.showConsoleInfo_ProcFile(UpCastProcessor.TASK, invoiceFile, methodName);
                    if(info.getFileFormat()==FileFormat.XML){
                        processXML(seqNo, invoiceFile, info); //處理XML
                    }else{
                        processFlatFile(seqNo, invoiceFile, info); //處理FlatFile
                        if(Processor.isInterruptFlag())
                            return;
                    }
                } catch (IOException e) {
                    logger.showConsoleError_IO(UpCastProcessor.TASK, e, methodName);
                    TurnkeyUtil.insertSysEvent(methodName, null, seqNo, null, e,  TurnkeyConstant.ErrorCodeEnum.IO.getValue(), this.getClass().getName(),this.getClass().getPackage().getName(),"Sys005");
                    throw e;
                } catch (XdaoException e) {
                    logger.showConsoleError_Xdao(UpCastProcessor.TASK, e, methodName);
                    chkDBStatus(methodName, e);
                } catch (Throwable t) {
                    logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0006") + invoiceFile.getName(), t, methodName);
                    TurnkeyUtil.insertSysEvent(methodName, null, seqNo, null, t,  TurnkeyConstant.ErrorCodeEnum.UNKNOWN.getValue(), this.getClass().getName(),this.getClass().getPackage().getName(),"Sys006");
                    continue;
                }
            }

            //將檔案搬至目的目錄
//            Set<BackupInfoBean> chkSrcFileSet = new HashSet<BackupInfoBean>();
            BackupInfoBean backupInfoBean = null;
            Map<File, File> processSrcFile = new TreeMap<File, File>();

            if(xmlMap.size()>0){
                logger.info("move procFile to target folder", methodName);
            }
//            long start = System.currentTimeMillis();
            for(String key: xmlMap.keySet()){
                try{
                    logger.info("xmlMap.key: " + key, methodName);
                    CastBean castBean = xmlMap.get(key);
                    File procFile = castBean.getXmlPath();

                    File targetFolder = new File(info.getTargetPath() + File.separator + TurnkeyConstant.SRC);
                    if(!targetFolder.exists()){
                        targetFolder.mkdirs();
                    }
                    
                    if(!procFile.exists()){
                        continue;
                    }
                    
                    File targetFile = new File(info.getTargetPath() + File.separator + TurnkeyConstant.SRC + File.separator+procFile.getName()+"_"+castBean.getCnt());

                    Map<File, StringBuffer> srcFilePair = castBean.getSrcFilePair();

                    String [] procFileName =  procFile.getName().split("_");

                    backupInfoBean = new BackupInfoBean();
                    backupInfoBean.setInfo(info);
                    backupInfoBean.setMethodName(methodName);
                    backupInfoBean.setSrcFilePair(srcFilePair);

                    if(procFileName.length >= 4){
                        logger.info("move procFile:" + procFile + " to " + targetFile, methodName);
                        logger.showConsoleInfo_MoveToTarget(UpCastProcessor.TASK, procFile, targetFile, methodName);
                        //搬檔前先lock PackProcessor.TASK
                        synchronized (PackProcessor.TASK) {
                            if(targetFile.exists()){
                                throw new IOException("Target file: "+ targetFile.getAbsolutePath()+" already existed!");
                            }
                            else if(!procFile.renameTo(targetFile)){
                                IOException e = new IOException("Fail to move " + procFile + " to " + targetFile);
                                throw e;
                            }
                        }
                        backupInfoBean.setSucess(true);
                    }else{
                        logger.error("file name format error" + procFile.getName(), methodName);
                        logger.showConsoleError_FileNameFormatError(UpCastProcessor.TASK, procFile, methodName);
                        String file = TurnkeyUtil.moveFileToFolderWithDayTime(procFile, info.getErrPath(),null,true);
                        logger.showConsoleError_MoveToErr(UpCastProcessor.TASK, procFile, new File(file + File.separator + procFile.getName()), methodName);
                        backupInfoBean.setSucess(false);
                    }
//                    chkSrcFileSet.add(backupInfoBean);
                    logger.info("bakupSrcFile..", methodName);
                    bakupSrcFile(backupInfoBean, processSrcFile);
                }catch (XdaoException e) {
                    logger.showConsoleError_Xdao(UpCastProcessor.TASK, e, methodName);
                    chkDBStatus(methodName, e);
                } catch (IOException e) {
                    logger.showConsoleError_IO(UpCastProcessor.TASK, e, methodName);
                    TurnkeyUtil.insertSysEvent(methodName, null, null, null, e,  TurnkeyConstant.ErrorCodeEnum.IO.getValue(), this.getClass().getName(),this.getClass().getPackage().getName(),"Sys005");
                    backupInfoBean.setSucess(false);
                }catch (Throwable t) {
                    logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0006"), t, methodName);
                    TurnkeyUtil.insertSysEvent(methodName, null, null, null, t, TurnkeyConstant.ErrorCodeEnum.UNKNOWN.getValue(), this.getClass().getName(),this.getClass().getPackage().getName(),"Sys999");
                    backupInfoBean.setSucess(false);
                }
            }
//            long end = System.currentTimeMillis();
//            System.out.println(end-start);

            totalCnt = 0;
//            xmlMap.clear();
            xmlMap = new HashMap<String, CastBean>();
            //2012.07.18 2775 重新scan
            files = srcPath.listFiles();
        }
    }


    public abstract void processXML(String seqNo, File invoiceFile, CastInfo info)  throws TurnkeyException, XdaoException, IOException;
    public abstract void processFlatFile(String seqNo, File invoiceFile, CastInfo info) throws TurnkeyException, XdaoException, IOException ;


    /**
     * 備份srcFile，並寫入MsgLogDtl
     * @param info
     * @param methodName
     * @param srcFiles
     * @param nameInfo
     * @throws XdaoException
     */
    protected void bakupSrcFile(BackupInfoBean backupInfoBean, Map<File, File> processSrcFile)
    throws XdaoException {
//        for(BackupInfoBean backupInfoBean: chkSrcFileSet){
            CastInfo info = backupInfoBean.getInfo();
            String methodName = backupInfoBean.getMethodName();
//            Map<String, File> srcFiles = backupInfoBean.getSrcFiles();
//
//            String[] nameInfo = backupInfoBean.getNameInfo();
            boolean success = backupInfoBean.isSucess();
            
            Map<File, StringBuffer> srcFilePair = backupInfoBean.getSrcFilePair();
            
            //避免同一次處理時，被分派到不同bak，在處理前先取好時間
            Calendar calender = Calendar.getInstance();
            String splitedFolder = GatewayUtil.getDate() + File.separator + String.valueOf(calender.get(Calendar.HOUR_OF_DAY));
            
            //來源可能多個，所以要loop
            for(File srcFile: srcFilePair.keySet()){
                StringBuffer sb = srcFilePair.get(srcFile);
                String[] seqPair = sb.toString().split(",");
                //確認是否搬過，搬過不再搬
                File srcBakFile = null;
                if(processSrcFile.containsKey(srcFile)){
                    srcBakFile = processSrcFile.get(srcFile);
                }else{
                    if(success)
                        srcBakFile = new File(info.getBakPath() + File.separator + splitedFolder + File.separator + srcFile.getName());
                    else
                        srcBakFile = new File(info.getErrPath() + File.separator + splitedFolder + File.separator + srcFile.getName());

                    if(!srcBakFile.getParentFile().exists()){
                        srcBakFile.getParentFile().mkdirs();
                    }
                    
                    File f = TurnkeyUtil.rename(srcFile, srcBakFile, false);

                    if(f.equals(srcFile)){
                        logger.info("move srcFile:" + srcFile + " to " + srcBakFile + " fail!", methodName);
                        logger.showConsoleError_MoveToBAK_Err(UpCastProcessor.TASK, srcFile, srcBakFile, methodName);
                        TurnkeyUtil.insertSysEvent(methodName, null, null, null, new TurnkeyException("move srcFile:" + srcFile + " to " + srcBakFile + " fail!"), TurnkeyConstant.ErrorCodeEnum.IO.getValue(), this.getClass().getName(),this.getClass().getPackage().getName(),"Sys005");
                        success = false;
                    }else{
                        logger.info("move srcFile:" + srcFile + " to " + f, methodName);
                        logger.showConsoleInfo_MoveToBAK(UpCastProcessor.TASK, srcFile, f, methodName);
                    }
                    srcBakFile = f;
                    processSrcFile.put(srcFile, srcBakFile);
                }

                logger.info("update log start : " + srcBakFile, methodName);
                List<TurnkeyMessageLog> msgLogList = new ArrayList<TurnkeyMessageLog>();
                for(int i=0; i<seqPair.length; i++){
                    String[] seqSubSeqPair = seqPair[i].split("\\.");
                    TurnkeyMessageLog msgLog = new TurnkeyMessageLog();
                    msgLog.setSeqno(seqSubSeqPair[0]);
                    msgLog.setSubseqno(seqSubSeqPair[1]);
                    msgLogList.add(msgLog);
                }
                String status;
                if(success)
                    status = TurnkeyConstant.STATUS_SUCCESS;
                else
                    status = TurnkeyConstant.STATUS_ERROR;
                    
                TurnkeyMessageLogService.INSTANCE.updMessageLogAndDetailInList(msgLogList, status, TaskEnum.UpCast, srcBakFile.getAbsolutePath(), null, null, info.getProcessType());
                
                logger.info("update log finish : " + srcBakFile, methodName);
            }
    }

    /**
     * 備份upCast的檔案
     * 
     * @param invoiceFile
     */
    protected void backupupCastFile(File invoiceFile) {
        String methodName = "backupupCastFile";
        logger.info("UpCast finish, move " + invoiceFile + " to" + info.getBakPath(), methodName);
        TurnkeyUtil.moveToPath(invoiceFile, info.getBakPath(), false);
    }

    /**
     * 檢查資料庫狀態
     * 
     * @param methodName
     * @param e
     * @throws XdaoException
     */
    protected void chkDBStatus(String methodName, XdaoException e) throws XdaoException {
        logger.error("occur XdaoException! chkDBStatus..", e, methodName);
        // TODO 判斷是否為連線錯誤
        // 先判斷db類型，如果是oracle判斷錯誤碼，如果是mysql判斷內容
        // 是則不寫db，且中斷，否則還是寫db
        
       TurnkeyUtil.chkDBConnectionReset(e);
       
       TurnkeyUtil.insertSysEvent(methodName, null, null, null, e, TurnkeyConstant.ErrorCodeEnum.DB.getValue(), this.getClass().getName(),this.getClass().getPackage().getName(),"Sys006");
    }

//    /**
//     * @param methodName
//     * @param partyId
//     * @param seqno
//     * @param subSeqno
//     * @param e
//     * @param errorCode
//     * @throws XdaoException
//     */
//    protected void insertSysEvent(String methodName, String partyId, String seqno, String subSeqno, Throwable e,
//            String errorCode) throws XdaoException {
//        logger.error("Occur SysEvent!!! :", e, methodName);
//        
//        TurnkeySysEventLog eventLog = new TurnkeySysEventLog(GatewayUtil.getDateTime(), partyId, // PartyId
//                seqno, // SeqNo
//                subSeqno, // SubSeqNo
//                errorCode, this.getClass().getName(), this.getClass().getPackage().getName(), methodName,
//                TurnkeyUtil.getSysLogMsg(e));
//        TurnkeySysEventService.INSTANCE.insertTrunkeySysEventLog(eventLog);
//    }

    /**
     * 建立CastBean以記錄處理狀況
     * @param invoiceFile
     * @param info
     * @param key
     * @return
     */
    protected CastBean createCastBean(File invoiceFile, String messageType, CastInfo info, String fromBan, String toBan, int createTime) {
        CastBean castBean = new CastBean();
        
        castBean.setEinvEnvelopeFileName(InvoiceUtil.getInvoiceEnvelopeFileName(EINVVersion.getLastVersion()
                .getVersion(), messageType));
        castBean.setXmlPath(new File(info.getProcPath().getAbsolutePath() + File.separator + invoiceFile.getName()
                + "_" + fromBan + "_" + toBan + "_" + castBean.getEinvEnvelopeFileName()));
        castBean.setTotalCnt(createTime);
        return castBean;
    }

    /**
     * 確認字集內容，並轉字集
     * 
     * @param msg
     * @throws CharsetException
     * @throws TurnkeyException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     */
    protected EINVPayload chkCharset(EINVPayload einvPayload, EncodingType srcEncoding)
    throws CharsetException {

        if (einvPayload == null)
            return null;

        einvPayload = charsetHelper.transCharset(einvPayload, srcEncoding, EncodingType.UTF8); // 轉換字集
        return einvPayload;
    }

    /**
     * 確認版本，並轉版本
     * 
     * @throws TurnkeyException
     * @throws TransformException
     */
    protected EINVPayload chkVersion(EINVPayload einvPayload, boolean bb2bc) throws TransformException {
        String methodName = "chkVersion";
        if (einvPayload == null)
            return null;

        try {
            einvPayload = transformHelper.transformToNewestVersion(einvPayload, bb2bc); // 轉換至最新版本
        } catch (TransformException e) {
            logger.error("chkVersion occur TransformException", e, methodName);
            if (e.getCause() != null) {
                logger.error("chkVersion occur TransformException, cause", e, methodName);
            }
            throw e;
        }
        return einvPayload;
    }


    /**
     * 備份專用的bean
     * @author 2775
     *
     */
    private class BackupInfoBean{
        CastInfo info;
        String methodName;
//        Map<String, File> srcFiles;
        private Map<File, StringBuffer> srcFilePair = new HashMap<File, StringBuffer>();

//        String[] nameInfo;
        boolean sucess;

        public CastInfo getInfo() {
            return info;
        }
        public void setInfo(CastInfo info) {
            this.info = info;
        }
        public String getMethodName() {
            return methodName;
        }
        public void setMethodName(String methodName) {
            this.methodName = methodName;
        }
//        public Map<String, File> getSrcFiles() {
//            return srcFiles;
//        }
//        public void setSrcFiles(Map<String, File> srcFiles) {
//            this.srcFiles = srcFiles;
//        }
//        public String[] getNameInfo() {
//            return nameInfo;
//        }
//        public void setNameInfo(String[] nameInfo) {
//            this.nameInfo = nameInfo;
//        }
        public boolean isSucess() {
            return sucess;
        }
        public void setSucess(boolean sucess) {
            this.sucess = sucess;
        }
        public Map<File, StringBuffer> getSrcFilePair() {
            return srcFilePair;
        }
        public void setSrcFilePair(Map<File, StringBuffer> srcFilePair) {
            this.srcFilePair = srcFilePair;
        }
    }
}

