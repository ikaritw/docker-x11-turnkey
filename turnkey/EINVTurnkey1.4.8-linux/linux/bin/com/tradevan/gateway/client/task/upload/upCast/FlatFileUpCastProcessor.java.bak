package com.tradevan.gateway.client.task.upload.upCast;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Map;

import org.apache.commons.validator.GenericValidator;

import com.tradevan.commons.io.FileUtil;
import com.tradevan.gateway.client.dao.bean.FromConfig;
import com.tradevan.gateway.client.dao.bean.TurnkeyMessageLog;
import com.tradevan.gateway.client.dao.bean.TurnkeyMessageLogDetail;
import com.tradevan.gateway.client.dao.service.FromConfigService;
import com.tradevan.gateway.client.dao.service.TurnkeyMessageLogService;
import com.tradevan.gateway.client.einv.charset.CharsetException;
import com.tradevan.gateway.client.einv.parse.ParserException;
import com.tradevan.gateway.client.einv.transform.TransformException;
import com.tradevan.gateway.client.einv.transport.CategoryType;
import com.tradevan.gateway.client.einv.transport.ProcessType;
import com.tradevan.gateway.client.einv.util.EncodingType;
import com.tradevan.gateway.client.einv.util.InvoiceConstant;
import com.tradevan.gateway.client.einv.validate.proc.ValidateConstant;
import com.tradevan.gateway.client.einv.validate.proc.ValidateResult;
import com.tradevan.gateway.client.exception.TurnkeyException;
import com.tradevan.gateway.client.task.Processor;
import com.tradevan.gateway.client.task.info.CastInfo;
import com.tradevan.gateway.client.task.others.VolumeInfoMaker;
import com.tradevan.gateway.client.task.upload.UpCastProcessor;
import com.tradevan.gateway.client.util.GatewayUtil;
import com.tradevan.gateway.client.util.MessageIdentifier;
import com.tradevan.gateway.client.util.TaskEnum;
import com.tradevan.gateway.client.util.TurnkeyConstant;
import com.tradevan.gateway.client.util.TurnkeyUtil;
import com.tradevan.gateway.einv.msg.EINVPayload;
import com.tradevan.taurus.xdao.XdaoException;

public class FlatFileUpCastProcessor extends UpCaster {

    public void processFlatFile(String seqNo, File invoiceFile, CastInfo info) throws TurnkeyException, XdaoException, IOException {

        String methodName = "processFlatFile";

        String payload = "";
        // 一次讀取筆數
        int maxReadNum = 1;
        boolean isFirStTime = true;
        int recordCnt = 0; // loop了幾次
        int sucessRecordCnt = 0; // 成功的筆數
        MessageIdentifier messageIdentifier = new MessageIdentifier();
        Class<? extends EINVPayload> clazz = info.getInvoiceClass();
//        String seqNo = "";
        String subSeqNo = "";
        String partyId = "";

        // 取得編碼後的seqNo
//        seqNo = TurnkeySequenceService.INSTANCE.getNextSequence();
        String header = "";
        try {
            header = parserHelper.getFlatFileInvoiceHeader(clazz, info.getEncoding());
        } catch (ParserException e1) {
            throw new TurnkeyException("get flat file header occur exception", e1);
        }
        //避免同一次處理時，被分派到不同bak，在處理前先取好時間
        Calendar calender = Calendar.getInstance();
        String splitedFolder = GatewayUtil.getDate() + File.separator + String.valueOf(calender.get(Calendar.HOUR_OF_DAY));

        // 讀取檔案
        BufferedInputStream bis = null;
        FileInputStream fis = null;
        ;
        EINVPayload einvPayload = null;
        try {
            
            fis = new FileInputStream(invoiceFile);
            bis = new BufferedInputStream(fis);
            // loop 直至讀取完畢
            do {
                einvPayload = null;
                try {
                    if(Processor.isInterruptFlag()){
                        interruptHandler();
                        return;
                    }
                    // 取得每筆訊息編碼後的subSeqNo
                    subSeqNo = messageIdentifier.getMessageSubId(recordCnt + 1);
                    recordCnt++;
                    
                    payload = "";
                    // 確認payload有內容後塞值，並更新至db內的msgLog中
                    payload = getInvoice(bis, clazz, maxReadNum, info.getEncoding(), isFirStTime, header);
                    payload = payload.trim();
//                    while(payload.endsWith("\r\n\r\n")){
//                        payload = payload.substring(0, payload.length()-2);
//                    }
                    isFirStTime = false;

                    if (GenericValidator.isBlankOrNull(payload)) {
                        if (recordCnt == 1) {
                            logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0038") + " " + invoiceFile, methodName);
                            throw new TurnkeyException("File is empty");
                        } else {
                            break;
                        }
                    }

                    TurnkeyMessageLog msgLog = new TurnkeyMessageLog();
                    msgLog.setCategoryType(info.getCategoryType());
                    msgLog.setSeqno(seqNo);
                    msgLog.setSubseqno(subSeqNo);
                    msgLog.setMessageType(info.getMessageType());
                    msgLog.setProcessType(info.getProcessType().getValue());
                    msgLog.setMessageDts(GatewayUtil.getDateTime());
                    msgLog.setStatus(TurnkeyConstant.STATUS_PROCESS);
                    msgLog.setInOutBound(TurnkeyConstant.OUTBOUND);
                    msgLog.setCharacterCount(String.valueOf(payload.length()));
                    TurnkeyMessageLogService.INSTANCE.insUpdMessageLog(msgLog); // 先寫

                    TurnkeyMessageLogDetail msgLogDetail = new TurnkeyMessageLogDetail();
                    msgLogDetail.setSeqno(seqNo);
                    msgLogDetail.setSubseqno(subSeqNo);
                    msgLogDetail.setProcessDts(msgLog.getMessageDts());
                    msgLogDetail.setTask(TaskEnum.UpCast.getValue());
                    msgLogDetail.setStatus(TurnkeyConstant.STATUS_PROCESS);
                    msgLogDetail.setFilename(invoiceFile.getAbsolutePath()); // 先寫目前檔名
                    TurnkeyMessageLogService.INSTANCE.updMessageLogDetail(msgLogDetail);

                    // 對訊息進行序列化, 一律Big5
                    List<EINVPayload> payloadList = parserHelper.unmarshalFromFlatFile(payload, clazz,
                           info.getEncoding());
                    einvPayload = payloadList.get(0);
                    

                    einvPayload = chkCharset(einvPayload, info.getEncoding());
                    einvPayload = chkVersion(einvPayload, info.getCategoryType()==CategoryType.B2C);
                    parserHelper.setXMLPaddingEncoding(false);
                    String xml = parserHelper.marshalToXML(einvPayload);
                    
                    xml = xml.replaceAll("<Attachment/>", "");
                    ValidateResult vr = validateHelper.validateXML(xml, einvPayload, einvPayload.getClass());
//                    System.out.println(xml);
                    
                    if (!vr.getErrorCode().equals(ValidateConstant.SUCESS[0])) {
                        logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0039") + " " + invoiceFile, vr.getException(), methodName);
                        logger.error("valid fail! " + vr.getErrorCode(), vr.getException(), methodName);
                        throw new TurnkeyException("valid fail! ", vr.getException());
                    }
                    
                    if(GenericValidator.isBlankOrNull(einvPayload.getFromBan())){ 
                        logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0056") + " " + invoiceFile, vr.getException(), methodName);
                        throw new TurnkeyException("valid fail! can not decide from ban or to ban");
                    }
                    
                    String key = "";
                    
                    String fromBan = einvPayload.getFromBan();
                    FromConfig fromCfg = FromConfigService.INSTANCE.queryByPKey(fromBan);
                    
                    if(info.getProcessType()==ProcessType.EXCHANGE){// 交換時，確認FromPartyId是否存在及內容是否合法
                        if(!TurnkeyUtil.chkFromConfig(fromCfg)){
                            logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("CanNotFindSenderPartyId")+ TurnkeyUtil.getMessage("UTL_M0025") +fromCfg, methodName);
                            fromCfg=null;
                            throw new TurnkeyException("From PartyId("+fromBan+") is no found or FromConfig is invaild");
                        }
                    }else{
                        if(!TurnkeyUtil.chkFromConfig(fromCfg)){  //存放時，先檢查是否有設定
                            if(!TurnkeyUtil.chkFromConfig(storageAgentFromCfg)){ //沒設定的話，檢查是否有代理人
                                logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("CanNotFindSenderPartyId")+ TurnkeyUtil.getMessage("UTL_M0025") +fromCfg, methodName);
                                fromCfg=null;
                                throw new TurnkeyException("From PartyId("+fromBan+") is no found or FromConfig is invaild");
                            }else{
                                fromCfg = storageAgentFromCfg;
                                fromBan = fromCfg.getPartyId();
                            }
                        }
                    }
                    
                    //B2C Store時, key=送方_00000000
                    String toBan = "";
                    if (ProcessType.STORAGE.equals(info.getProcessType()))
                    {
                        key = einvPayload.getFormat() + "_" + fromBan + "_" + TurnkeyConstant.INVOICE_B2C_TOPARTY_ID ;
                        toBan = TurnkeyConstant.INVOICE_B2C_TOPARTY_ID;
                    }else{
                        //B2B 的key
                        if( GenericValidator.isBlankOrNull(einvPayload.getToBan())){
                            logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0056") + " " + invoiceFile, vr.getException(), methodName);
                            throw new TurnkeyException("valid fail! can not decide from ban or to ban");
                        }    
                         key = einvPayload.getFormat() + "_" +fromBan + "_" + einvPayload.getToBan();
                         toBan = einvPayload.getToBan();
                    }

                    CastBean castBean = null;
                    
                    if(xmlMap.containsKey(key)){
                        castBean = xmlMap.get(key);
                    }else{
                        castBean = createCastBean(invoiceFile, einvPayload.getFormat(), info, fromBan, toBan, 0);
                    }

                    // 更新castBean
                    xmlMap.put(key, castBean);
                    
//                    xml = xml.replace((InvoiceConstant.XML_HEADER + "\r\n"), "");
//                    xml = xml.replace((InvoiceConstant.XML_HEADER), ""); // 預防換行不是\r\n的情況
                    byte[] xmlByte = (xml + "\r\n").getBytes(EncodingType.UTF8.getValue());
                    FileUtil.write(castBean.getXmlPath(), xmlByte, true);
            
                    castBean.addSrcFilePair(invoiceFile, seqNo+"."+subSeqNo);
                    castBean.addCnt();
                    castBean.addFileSize(xmlByte.length);
                    
                    String[] nameInfo = castBean.getEINVEnvelopeFileNameInfo();
                    msgLog.setUuid(nameInfo[3]);
                    // 更新處理時間為UUID時間
                    msgLog.setMessageDts(nameInfo[2].replace("-", ""));
                    // 更新發票資訊
                    msgLog.setInvoiceIdentifier(einvPayload.getInvoiceIdentifier());
                    // 更新收送方
                    msgLog.setFromPartyId(fromBan);

                    if (info.getCategoryType().equals(CategoryType.B2B))
                        msgLog.setToPartyId(einvPayload.getToBan());
                    else
                        msgLog.setToPartyId(TurnkeyConstant.INVOICE_B2C_TOPARTY_ID);

                    TurnkeyMessageLogService.INSTANCE.insUpdMessageLog(msgLog);
                    //有附檔、交換、檔案大小超過最大size、檔案發票超過1000包，包成一包
                    if(einvPayload.isAttachment() || ProcessType.EXCHANGE.equals(info.getProcessType()) || castBean.getFileSize() > TurnkeyConstant.MAX_INVOICE_SIZE || castBean.getCnt()>=TurnkeyConstant.MAX_INVOICE_NUM){
                        xmlMap.put(key + "." + castBean.getTotalCnt(), castBean);
                        castBean = createCastBean(invoiceFile, einvPayload.getFormat(), info, fromBan, toBan, castBean.getTotalCnt() + 1);
                        xmlMap.remove(key);
                    }
                    xmlMap.put(key, castBean);
                    // 更新uuid
//                    msgLogDetail.setUuid(nameInfo[3]);
                    // 更新為UUID時間
//                    msgLogDetail.setProcessDts(nameInfo[2].replace("-", ""));
//                    TurnkeyMessageLogService.INSTANCE.updMessageLogDetail(msgLogDetail);
                    totalCnt++;
                    sucessRecordCnt++;
                } catch (TurnkeyException e) {
                    logger.error("TurnkeyException", e, methodName);
                    if(e.getCause()!=null){
                        logger.error("TurnkeyException", e.getCause(), methodName);
                        processFlatFileErrorHandle(info, methodName, partyId, seqNo, subSeqNo, e.getCause(),  TurnkeyConstant.ErrorCodeEnum.INVOICE_INVAILD.getValue(),
                                splitedFolder, payload, invoiceFile.getName(),"Sys001", einvPayload);
                    }else{
                        processFlatFileErrorHandle(info, methodName, partyId, seqNo, subSeqNo, e,  TurnkeyConstant.ErrorCodeEnum.INFO.getValue(),
                                splitedFolder, payload, invoiceFile.getName(),"CanNotFindSenderPartyId", einvPayload);
                    }
                } catch (ParserException e) {
                    logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0019") + invoiceFile, e, methodName);
                    logger.error("ParserException:" + e.getMessage(), methodName);
                    processFlatFileErrorHandle(info, methodName, partyId, seqNo, subSeqNo, e,
                    		 TurnkeyConstant.ErrorCodeEnum.PARSER.getValue(), splitedFolder, payload, invoiceFile.getName(),"Sys002", einvPayload);
                } catch (TransformException e) {
                    logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0020") + invoiceFile, e, methodName);
                    logger.error("TransformException:" + e.getMessage(), methodName);
                    processFlatFileErrorHandle(info, methodName, partyId, seqNo, subSeqNo, e,
                    		 TurnkeyConstant.ErrorCodeEnum.TRANSFORM.getValue(), splitedFolder, payload, invoiceFile.getName(),"Sys003", einvPayload);
                } catch (CharsetException e) {
                    logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0040") + invoiceFile, e, methodName);
                    logger.error("CharsetException:" + e.getMessage(), methodName);
                    processFlatFileErrorHandle(info, methodName, partyId, seqNo, subSeqNo, e,
                    		 TurnkeyConstant.ErrorCodeEnum.CHARSET.getValue(), splitedFolder, payload, invoiceFile.getName(),"Sys004", einvPayload);
                } catch (FileNotFoundException e) {
                    logger.error("FileNotFoundException:" + e.getMessage(), e, methodName);
                    throw e;
                } catch (IOException e) {
                    logger.error("IOException:" + e.getMessage(), methodName);
                    throw e;
                } catch (XdaoException e) {
                    logger.error("XdaoException:" + e.getMessage(), methodName);
                    throw e;
                }

            } while (true);
        } catch (FileNotFoundException e1) {
            logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0021") + invoiceFile, e1, methodName);
            logger.error("Invoice file not find" + invoiceFile.getAbsolutePath(), e1, methodName);
            throw new TurnkeyException("file not found : " + invoiceFile.getAbsolutePath(), e1);
        } finally {
            if (bis != null) {
                try {
                    bis.close();
                } catch (IOException e) {
                }
            }
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                }
            }
        }
        
        // 表示至少有一筆，且
        if (recordCnt > 1) {
            // 沒成功半筆，就砍檔，因為已寫到err了
            if (sucessRecordCnt == 0) {
                VolumeInfoMaker.moveProcVolumeInfoToTarget(invoiceFile.getName(), true, recordCnt-1);
                invoiceFile.delete();
            }
        } else {
            //空檔
            cleanFile(invoiceFile, info, methodName, splitedFolder);
        }
    }

    public void interruptHandler() throws XdaoException{
        String methodName = "interruptHandler";
        logger.error("Interrupt upcast: ", methodName);
        logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0022"), methodName);
        for(String key: xmlMap.keySet()){
            try{
                logger.info("xmlMap.key: " + key, methodName);
                CastBean castBean = xmlMap.get(key);

                Map<File, StringBuffer> srcFilePair = castBean.getSrcFilePair();

                for(File srcFile: srcFilePair.keySet()){
                    logger.info("update log start : " + srcFile, methodName);
                    
                    StringBuffer sb = srcFilePair.get(srcFile);
                    String[] seqPair = sb.toString().split(",");
                    List<TurnkeyMessageLog> msgLogList = new ArrayList<TurnkeyMessageLog>();
                    for(int i=0; i<seqPair.length; i++){
                        String[] seqSubSeqPair = seqPair[i].split("\\.");
                        TurnkeyMessageLog msgLog = new TurnkeyMessageLog();
                        msgLog.setSeqno(seqSubSeqPair[0]);
                        msgLog.setSubseqno(seqSubSeqPair[1]);
                        msgLogList.add(msgLog);
                    }
                    TurnkeyMessageLogService.INSTANCE.updMessageLogAndDetailInList(msgLogList, TurnkeyConstant.STATUS_INTERRUPT, TaskEnum.UpCast, srcFile.getAbsolutePath(), null, null, info.getProcessType());
                }
            }catch (XdaoException e) {
                chkDBStatus(methodName, e);
            }
        }
    }

    /**
     * 清除檔案
     * @param invoiceFile
     * @param info
     * @param methodName
     * @param splitedFolder
     */
    private void cleanFile(File invoiceFile, CastInfo info, String methodName, String splitedFolder) {
        File targetFile = new File(info.getErrPath() + File.separator + splitedFolder);
        if (!targetFile.exists()) {
            targetFile.mkdirs();
        }
        try {
            FileUtil.move(invoiceFile, targetFile);
        } catch (IOException e) {
            // 搬失敗，直接刪檔
            logger.error("occur IOException! " + e.getMessage() + "delete file!" + invoiceFile.getName(), e, methodName);
            invoiceFile.delete();
        }
    }
    
    

    /**
     * 負責錯誤處理，將檔案寫到指定folder
     * 
     * @param info
     * @param methodName
     * @param partyId
     * @param seqNo
     * @param subSeqNo
     * @param e
     * @param errorCode
     * @param splitFolder
     *            yyyyMMdd/hh
     * @throws XdaoException
     * @throws IOException
     */
    private void processFlatFileErrorHandle(CastInfo info, String methodName, String partyId, String seqNo,
            String subSeqNo, Throwable e, String errorCode, String splitFolder, String payload, String filename,String propertyCode, EINVPayload einvPayload)
            throws XdaoException, IOException{
        //若需制作檔案清冊
        if(ProcessType.STORAGE.equals(info.getProcessType())){
            VolumeInfoMaker.makeVolumeInfoForUpcast(filename, einvPayload, payload, info.getMessageType(), errorCode, e);
        }
        TurnkeyUtil.insertSysEvent(methodName, partyId, seqNo, subSeqNo, e, errorCode, this.getClass().getName(),this.getClass().getPackage().getName(),propertyCode);
        File targetFile = new File(info.getErrPath() + File.separator + splitFolder + File.separator + filename);
        logger.error("Message occur error write msg to " + targetFile, e, methodName);
        logger.showConsoleError(UpCastProcessor.TASK, TurnkeyUtil.getMessage("UTL_M0020") + " " + TurnkeyUtil.getMessage("UTL_M0041") + targetFile, methodName);
        FileUtil.write(targetFile, (payload + "\r\n").getBytes(info.getEncoding().getValue()), true);
        TurnkeyMessageLog msgLog = new TurnkeyMessageLog();
        msgLog.setSeqno(seqNo);
        msgLog.setSubseqno(subSeqNo);
        msgLog.setStatus(TurnkeyConstant.STATUS_ERROR);
         
        if(einvPayload!=null){
            msgLog.setInvoiceIdentifier(einvPayload.getInvoiceIdentifier());
        }
        
        TurnkeyMessageLogService.INSTANCE.insUpdMessageLog(msgLog); // 先寫

        TurnkeyMessageLogDetail msgLogDetail = new TurnkeyMessageLogDetail();
        msgLogDetail.setSeqno(seqNo);
        msgLogDetail.setSubseqno(subSeqNo);
        msgLogDetail.setTask(TaskEnum.UpCast.getValue());
        msgLogDetail.setStatus(TurnkeyConstant.STATUS_ERROR);
        msgLogDetail.setFilename(targetFile.getAbsolutePath()); // 先寫目前檔名
        TurnkeyMessageLogService.INSTANCE.updMessageLogDetail(msgLogDetail);
    }

    /**
     * 取得發票內容，最大筆數由maxReadNum控制
     * 
     * @param fileReader
     * @param maxReadNum
     * @return
     * @throws IOException
     * @throws Exception
     */
    private String getInvoice(BufferedInputStream bis, Class<? extends EINVPayload> clazz, int maxReadNum,
            EncodingType encoding, boolean isFirstTime, String header) throws IOException {

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        BufferedOutputStream bos = new BufferedOutputStream(baos);
        try {
            byte[] eolHeader = ("\n" + header).getBytes(encoding.getValue());
            byte[] reversRN = "\r\n".getBytes();
            int count = 0;
            byte tmpByte;
            int i = 0;
            int tmpcnt = 0;
            boolean writeHeader = true;
            while ((tmpByte = (byte) bis.read()) != -1) {
                tmpcnt++;
                if (!isFirstTime && writeHeader) { // 因為，如果不是第一次讀，則M己經被前一次給讀走，需補回去
                    bos.write(header.getBytes(encoding.getValue()));
                    writeHeader = false;
                }
                if (tmpByte == eolHeader[i]) {
                    i++;
                } else if (i > 0) {
                    i = 0;
                    if (tmpByte == eolHeader[i]) {
                        i++;
                    }
                }
                if (i == eolHeader.length) {
                    i = 0;
                    count++;
                }
                if (count >= maxReadNum) {
                    break;
                }else if(tmpByte == reversRN[0]){
                    //遇到\r(0D)時不做不寫
                }else if(tmpByte == reversRN[1]){
                    bos.write(reversRN);
                    //遇到\n(0A)時補上0D
                }else{
                    bos.write(tmpByte);
                    //其實照寫
                }
            }
        } finally {
            if (bos != null)
                bos.close();
            if (baos != null)
                baos.close();
        }
        return new String(baos.toByteArray(), encoding.getValue());
    }

    @Override
    public void processXML(String seqNo, File invoiceFile, CastInfo info) {
    }
    

    /**
     * 確認字集內容，並轉字集
     * 
     * @param msg
     * @throws CharsetException
     * @throws TurnkeyException
     * @throws IllegalAccessException
     * @throws IllegalArgumentException
     */
    protected EINVPayload chkCharset(EINVPayload einvPayload, EncodingType srcEncoding)
    throws CharsetException {

        if (einvPayload == null)
            return null;

        einvPayload = charsetHelper.transCharset(einvPayload, srcEncoding, EncodingType.UTF8); // 轉換字集
        return einvPayload;
    }
}
